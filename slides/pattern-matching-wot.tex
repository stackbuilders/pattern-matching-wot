\documentclass{beamer}

\usetheme{default}

\setbeamertemplate{navigation symbols}{}

\usepackage{polyglossia}

\setdefaultlanguage[variant=usmax]{english}

\usepackage{fancyvrb}
\usepackage{relsize}

\DefineShortVerb{\|}
\DefineVerbatimEnvironment{code}{Verbatim}{fontsize=\relsize{-1},frame=lines}

\title{Pattern Matching}
\subtitle{Wot's... Uh the Deal?}
\author{}
\institute{Stack Builders}
\date{0.1.0}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\frame{\titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
  \frametitle{Praise for pattern matching}

  \begin{quote}
    The patch will not be noticeable if the pattern is skilfully
    matched.
  \end{quote}
  \hfill---Idabelle McGlauflin, \emph{Handicraft for Girls}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
  \frametitle{Wot's... Uh the Deal?}

  \begin{itemize}
  \item
    \begin{code}
newtype N = N  Bool
data    D = D !Bool
    \end{code}
  \item
    \begin{code}
> (\  (N True) -> True) undefined
?
> (\  (D True) -> True) undefined
?
    \end{code}
  \item
    \begin{code}
> (\ ~(N True) -> True) undefined
?
> (\ ~(D True) -> True) undefined
?
    \end{code}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Wot's... Uh the Deal?}

  \begin{itemize}
  \item
    \begin{code}
newtype N = N  Bool
data    D = D !Bool
    \end{code}
  \item
    \begin{code}
> (\  (N True) -> True) undefined
undefined
> (\  (D True) -> True) undefined
undefined
    \end{code}
  \item
    \begin{code}
> (\ ~(N True) -> True) undefined
True
> (\ ~(D True) -> True) undefined
True
    \end{code}
  \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
  \frametitle{Sd}

  \begin{block}{Booleans}
    \begin{itemize}
    \item
      \begin{code}
data Bool = False | True
      \end{code}
    \item
      \begin{code}
not :: Bool -> Bool
not False = True
not True  = False
      \end{code}
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Sd}

  \begin{block}{Maybe}
    \begin{itemize}
    \item
      \begin{code}
data Maybe a = Nothing | Just a
      \end{code}
    \item
      \begin{code}
isNothing :: Maybe a -> Bool
isNothing Nothing = True
isNothing _       = False
      \end{code}
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Sd}

  \begin{block}{Lists}
    \begin{itemize}
    \item
      \begin{code}
data [] a = [] | a : [a]
      \end{code}
    \item
      \begin{code}
map :: (a -> b) -> [a] -> [b]
map _ []     = []
map f (x:xs) = f x : map f xs
      \end{code}
    \end{itemize}
  \end{block}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
  \frametitle{Pattern matching}
  \framesubtitle{Patterns}

  \begin{example}
    \begin{code}
span :: (a -> Bool) -> [a] -> ([a],[a])
span _ xs@[]       = (xs,xs)
span p xs@(x:xs')
  | p x            = let (ys,zs) = span p xs' in (x:ys,zs)
  | otherwise      = ([],xs)
    \end{code}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Pattern matching}
  \framesubtitle{Patterns}

  \begin{example}
    \begin{itemize}
    \item
      \begin{code}
foldr :: (a -> b -> b) -> b -> [a] -> b
foldr _ n []     = n
foldr c n (x:xs) = c x (foldr c n xs)
      \end{code}
    \item
      \begin{code}
unzip :: [(a,b)] -> ([a],[b])
unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
      \end{code}
    \end{itemize}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Pattern matching}
  \framesubtitle{Patterns}

  \begin{example}
    \begin{code}
fromMaybe :: a -> Maybe a -> a
fromMaybe d mx =
  case mx of
    Nothing -> d
    Just x  -> x
    \end{code}
  \end{example}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
  \frametitle{}

  \begin{code}
undefined :: a
undefined = undefined
  \end{code}
\end{frame}

\begin{frame}[fragile]
  \frametitle{}

  \begin{code}
const1 :: a -> Int
const1 x = 1
  \end{code}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
  \frametitle{Informal semantics of pattern matching}
  \framesubtitle{Several species of small furry \texttt{null} functions}

  \begin{code}
null1 :: [a] -> Bool
null1 []    = True
null1 (_:_) = False
  \end{code}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Informal semantics of pattern matching}
  \framesubtitle{Several species of small furry \texttt{null} functions}

  \begin{code}
null2 :: [a] -> Bool
null2 []    = True
null2 _     = False
  \end{code}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
  \frametitle{}

  \begin{examples}
    \begin{itemize}
    \item<1->
      If |['a','b']| is matched against |['x',undefined]|, then
      \begin{itemize}
      \item<2->
        |'a'| \emph{fails} to match against |'x'|, and
      \item<2->
        the result is a failed match.
      \end{itemize}
    \item<1->
      If |['a','b']| is matched against |[undefined,'x']|, then
      \begin{itemize}
      \item<2->
        attempting to match |'a'| against |undefined| causes the match
        to \emph{diverge}.
      \end{itemize}
    \end{itemize}
  \end{examples}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
  \frametitle{Informal semantics of pattern matching}

  \begin{example}
    \begin{code}
> (\ ~(x,y) -> 0) undefined

> (\  (x,y) -> 0) undefined

    \end{code}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Informal semantics of pattern matching}

  \begin{example}
    \begin{code}
> (\ ~(x,y) -> 0) undefined
0
> (\  (x,y) -> 0) undefined
undefined
    \end{code}
  \end{example}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
  \frametitle{Informal semantics of pattern matching}

  \begin{example}
    \begin{code}
> (\ ~[x] -> 0) []

> (\ ~[x] -> x) []

    \end{code}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Informal semantics of pattern matching}

  \begin{example}
    \begin{code}
> (\ ~[x] -> 0) []
0
> (\ ~[x] -> x) []
undefined
    \end{code}
  \end{example}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
  \frametitle{Informal semantics of pattern matching}

  \begin{example}
    \begin{code}
> (\ ~[x,~(a,b)] -> x) [(0,1),undefined]

> (\ ~[x, (a,b)] -> x) [(0,1),undefined]

    \end{code}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Informal semantics of pattern matching}

  \begin{example}
    \begin{code}
> (\ ~[x,~(a,b)] -> x) [(0,1),undefined]
(0,1)
> (\ ~[x, (a,b)] -> x) [(0,1),undefined]
undefined
    \end{code}
  \end{example}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
  \frametitle{Informal semantics of pattern matching}

  \begin{example}
    \begin{code}
> (\  (x:xs) -> x:x:xs) undefined

> (\ ~(x:xs) -> x:x:xs) undefined

    \end{code}
  \end{example}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Informal semantics of pattern matching}

  \begin{example}
    \begin{code}
> (\  (x:xs) -> x:x:xs) undefined
undefined
> (\ ~(x:xs) -> x:x:xs) undefined
undefined:undefined:undefined
    \end{code}
  \end{example}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
  \frametitle{Informal semantics of pattern matching}
  \framesubtitle{Several species of small furry \texttt{take} functions}

  \begin{code}
take1 :: Int -> [a] -> [a]
take1 n _      | n <= 0 = []
take1 _ []              = []
take1 n (x:xs)          = x : take1 (n - 1) xs
  \end{code}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Informal semantics of pattern matching}
  \framesubtitle{Several species of small furry \texttt{take} functions}

  \begin{code}
take1 :: Int -> [a] -> [a]
take1 n _      | n <= 0 = []
take1 _ []              = []
take1 n (x:xs)          = x : take1 (n - 1) xs
  \end{code}
  \begin{code}
> take1 undefined []

> take1 0 undefined

  \end{code}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Informal semantics of pattern matching}
  \framesubtitle{Several species of small furry \texttt{take} functions}

  \begin{code}
take1 :: Int -> [a] -> [a]
take1 n _      | n <= 0 = []
take1 _ []              = []
take1 n (x:xs)          = x : take1 (n - 1) xs
  \end{code}
  \begin{code}
> take1 undefined []
undefined
> take1 0 undefined
[]
  \end{code}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Informal semantics of pattern matching}
  \framesubtitle{Several species of small furry \texttt{take} functions}

  \begin{code}
take2 :: Int -> [a] -> [a]
take2 _ []              = []
take2 n _      | n <= 0 = []
take2 n (x:xs)          = x : take2 (n - 1) xs
  \end{code}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Informal semantics of pattern matching}
  \framesubtitle{Several species of small furry \texttt{take} functions}

  \begin{code}
take2 :: Int -> [a] -> [a]
take2 _ []              = []
take2 n _      | n <= 0 = []
take2 n (x:xs)          = x : take2 (n - 1) xs
  \end{code}
  \begin{code}
> take2 undefined []

> take2 0 undefined

  \end{code}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Informal semantics of pattern matching}
  \framesubtitle{Several species of small furry \texttt{take} functions}

  \begin{code}
take2 :: Int -> [a] -> [a]
take2 _ []              = []
take2 n _      | n <= 0 = []
take2 n (x:xs)          = x : take2 (n - 1) xs
  \end{code}
  \begin{code}
> take2 undefined []
[]
> take2 0 undefined
undefined
  \end{code}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Informal semantics of pattern matching}
  \framesubtitle{Several species of small furry \texttt{take} functions}

  \begin{code}
> take1 undefined []
undefined
> take1 0 undefined
[]
  \end{code}
  \begin{code}
> take2 undefined []
[]
> take2 0 undefined
undefined
  \end{code}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Informal semantics of pattern matching}
  \framesubtitle{Several species of small furry \texttt{take} functions}

  \begin{code}
take1' :: Int -> [a] -> [a]
take1' n xs     | n <= 0 = seq xs []
take1' _ []              = []
take1' n (x:xs)          = x : take1' (n - 1) xs
  \end{code}
  \begin{code}
> take1' undefined []
undefined
> take1' 0 undefined
undefined
  \end{code}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Informal semantics of pattern matching}
  \framesubtitle{Several species of small furry \texttt{take} functions}

  \begin{code}
take2' :: Int -> [a] -> [a]
take2' n []              = seq n []
take2' n _      | n <= 0 = []
take2' n (x:xs)          = x : take2' (n - 1) xs
  \end{code}
  \begin{code}
> take2' undefined []
undefined
> take2' 0 undefined
undefined
  \end{code}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
  \frametitle{Formal semantics of pattern matching}

  Sd.
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
  \frametitle{Bibliography}

  \begin{thebibliography}{Hudak, Peterson, and Fasel 1999}
  \setbeamertemplate{bibliography item}[article]
  \bibitem[Hudak, Peterson, and Fasel 1999]{hudak-peterson-fasel-1999}
    Hudak, Paul, John Peterson, and Joseph H. Fasel (1999).
    \newblock \emph{A Gentle Introduction to Haskell 98}.
    \newblock \url{https://www.haskell.org/tutorial/}
  \setbeamertemplate{bibliography item}[article]
  \bibitem[Marlow 2010]{marlow-2010}
    Marlow, Simon, editor (2010).
    \newblock \emph{Haskell 2010 Language Report}.
    \newblock \url{https://www.haskell.org/onlinereport/haskell2010/}
  \end{thebibliography}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
